\input texinfo
@setfilename gnubg.info
@settitle GNU Backgammon
@include version.texi

@set month-year August, 2002

@syncodeindex vr cp

@macro gnubg
@t{gnubg}
@end macro

@dircategory Games
@direntry
* gnubg: (gnubg).               GNU Backgammon.
@end direntry

@ifinfo
This file documents GNU Backgammon, a program for playing and analysing
backgammon games and matches.

Copyright @copyright{} 1999, 2000, 2001, 2002 Gary Wong, Achim Mueller.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1; with
no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".
@end ifinfo

@titlepage
@sp 10
@title GNU Backgammon
@subtitle version @value{VERSION}
@subtitle @value{month-year}
@author Gary Wong, Achim Mueller
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1999, 2000, 2001, 2002 Gary Wong, Achim Mueller

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1; with
no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".
@end titlepage

@ifnottex
@node Top
@top GNU Backgammon

This manual describes how to use GNU Backgammon to play and analyse
backgammon games and matches.  It corresponds to version @value{VERSION}
(updated in @value{month-year}).

@menu
* Introduction::			What is GNU Backgammon.
* For the impatient::			A short description how to use GNU Backgammon.
* How to play backgammon::		The rules of the game.
* Installing the software::		How to install GNU Backgammon under MS Windows, FreeBSD and Linux.
* Starting GNU Backgammon::		Starting the software using a terminal and the graphical user interface (GUI)
* Playing backgammon::			How to play a game, match or session.
* Saving games::			How to save your positions, games, matches and sessions.
* Opening files::			How to open saved positions, games, matches and sessions.
* Import and export::			Opening and saving from and into different formats.
* Settings::				Changing settings in GNU Backgammon.
* Analysis and rollouts::		How to analyse positions, games, matches or sessions.
* Position and match IDs::		A brief technical explanation.
* Cubeful equities::                    How do @gnubg{} calculate cubeful equities.
* Training::				How to store databases and train the neural nets.
* Bearoff databases::                   How to generate bearoff databases for use with GNU Backgammon
* Frequently Asked Questions::		A bunch of questions and answers (mostly taken from r.g.b.).
* GNU Free Documentation License::	Your rights regarding this manual.
* Command Index::                       Index of available commands
* Concept Index::                       Index
@end menu
@end ifnottex

@node Introduction
@chapter Introduction



@node For the impatient
@chapter For the impatient
@menu
* Installing the binaries::
* Playing a game::
@end menu

@node Installing the binaries
@section Installing the binaries

@node Playing a game
@section Playing a game

@node How to play backgammon
@chapter How to play backgammon



@node Installing the software
@chapter Installing the software
@menu
* Installing a MS Windows binary::
* Installing a Linux rpm-package::
* Installing a FreeBSD package or port::
* Compiling and installing the source::
@end menu

@node Installing a MS Windows binary
@section Installing a MS Windows binary

@node Installing a Linux rpm-package
@section Installing a Linux rpm-package

@node Installing a FreeBSD package or port
@section Installing a FreeBSD package or port

@node Compiling and installing the source
@section Compiling and installing the source


@node Starting GNU Backgammon
@chapter Starting GNU Backgammon
@menu
* The graphical interface::
* Using a terminal::
@end menu

@node The graphical interface
@section The graphical interface

@node Using a terminal
@section Using a terminal

@node Playing backgammon
@chapter Playing backgammon
@menu
* Starting a game or match or session::
* Moving the checkers::
* Using the doubling cube::
@end menu

@node Starting a game or match or session
@section Starting a game or match or session

@node Moving the checkers
@section Moving the checkers

@node Using the doubling cube
@section Using the doubling cube



@node Saving games
@chapter Saving games
@menu
* Saving a game::
* Saving a match::
* Saving a session::
* Saving a position::
@end menu

@node Saving a game
@section Saving a game

@node Saving a match
@section Saving a match

@node Saving a session
@section Saving a session

@node Saving a position
@section Saving a position



@node Opening files
@chapter Opening files
@menu
* Opening a game::
* Opening a match::
* Opening a session::
* Opening a position::
@end menu

@node Opening a game
@section Opening a game

@node Opening a match
@section Opening a match

@node Opening a session
@section Opening a session

@node Opening a position
@section Opening a position



@node Import and export
@chapter Import and export
@menu
@gnubg{} can import matches produced by various other programs or
online servers. For example, you can import matches played on 
@uref{http://www.gamesgrid.com/,GamesGrid} or 
@uref{http://www.fibs.com/,FIBS}. @gnubg can export positions,
matches, or money session to a number of formats; some suitable for
printing, some suitable for including in emails or Usenet postings,
and others suitable for publishing on the world wide web or for
posting to backgammon forums.

The following sections describe how to import and export positions,
matches, and sessions with @gnubg{}.

* Importing:: Importing positions, matches, and sessions
* Exporting:: Exporting positions, matches, and sessions
@end menu

@node Importing
@section Importing positions, matches, and sessions

@subsection Jellyfish .pos
@cindex Jellyfish
@cindex .pos
@cindex pos

@gnubg{} can import positions in 
@uref{http://jelly.effect.no/,Jellyfish}
.pos format. To import a position
file using the GUI select a file from @code{File->Import->.pos
position}. 

The .pos position format is documented at
@uref{http://jelly.effect.no/fspec.htm,The Jellyfish Position File
Format}. 

@subsection Jellyfish .mat
@cindex Jellyfish
@cindex .mat
@cindex mat
@cindex BBGT

@gnubg{} can also import matches and money sessions in the .mat
format. This format is often used to move games between different
programs, as most programs (e.g., Jellyfish, Snowie, BGBlitz, and
others) support import and export of this format.

To import a match or money session in the .mat format, select a file
from @code{File->Import->.mat match}.

Note that at least one program (BBGT) is known to write multiple matches in
the same .mat file. In this case @gnubg{} will only read the first
match. If you wish to import all matches from such a .mat file, you'll
manually have to split the file into files containing the individual
matches. 

@subsection GamesGrid .sgg
@cindex GamesGrid
@cindex sgg
@cindex .sgg

@gnubg{} can import matches and money sessions played on GamesGrid if
saved in the SGG format. Currently, @gnubg{} doesn't support import of
the native undocumented .cbg format. Also note
that @gnubg{} does not analyse table stakes, so imported money
sessions will be analysed as a normal money session.

To import an SGG file using the GUI select a file using the menu entry
@code{File->Import->.sgg match}. 

@subsection FIBS oldmoves
@cindex FIBS
@cindex oldmoves

@gnubg{} can import matches and money sessions from FIBS
in the oldmoves format. Most of the GUIs for playing on FIBS supports
saving of matches either in the oldmoves format or in Jellyfish .mat
format.

To import an oldmoves file using the GUI select a file using the menu
entry @code{File->Import->FIBS oldmoves}.

Note that @gnubg{} will only read the first match in the file. If you
wish to import all matches from a file containing more than more game,
you'll manually have to split it.

@subsection TrueMoneyGames .tmg
@cindex TrueMoneyGames
@cindex .tmg
@cindex tmg

@gnubg{} can also import matches and money sessions played on
TrueMoneyGames saved in the TMG format (file suffix .tmg). Please note
that @gnubg{} does not analyse table stakes, so imported money
sessions will be analysed as a normal money session.

To import an TMG file using the GUI select a file using the menu entry
@code{File->Import->TrueMoneyGames .tmg match}. 

@subsection Hans Berliner BKG format
@cindex Hans Berliner
@cindex .bkg
@cindex bkg

Matches written in the Hans Berliner BKG format can be imported into
@gnubg{}. To import an BKG file using the GUI select a file using the
menu entry @code{File->Import->BKG session}.


@subsection Snowie .txt position format
@cindex Snowie
@cindex Snowie .txt position format

@gnubg{} can import positions written in the Snowie .txt position
format. Please note that very important distinction between
@emph{Snowie .txt position} and @emph{Snowie Standard Text}. The
former is used for position and the latter is an extension of the
Jellyfish .mat format, and can be imported in @gnubg{} using the .mat
importer. 

@gnubg{} can also export positions to Snowie .txt format for easy
exchange of positions with Snowie users.

To import an Snowie .txt position file using the GUI select a file
using the menu entry @code{File->Import->Snowie .txt position file}.


@subsection Batch import
@cindex import, batch

@gnubg{} doesn't support batch import and analysis using the GUI, but
batch import is possible with the command line version of @gnubg{}.

Under Unix execute:

@code{gnubg -t < @var{input-file} > @var{output-file}}

Under Windows it depends on how your version of gnubg was build. For
example, if you use the build by Øystein Johansen you should execute

@code{gnubg-no-gui.exe < @var{input-file} > @var{output-file}}

The @var{input-file} must be carefully prepared. For example, it
could look like:

@verbatim
import sgg file1.sgg
analyse match
save match file1.sgf
import sgg file2.sgg
analyse match
save match file1.sgf
import mat file3.mat
analyse match
save match file3.sgf
@end verbatim

If you wish to adjust your setting for the analysis you can include
commands like:

@verbatim
set analysis chequerplay evaluation plies 2
set analysis cubedecision evaluation plies 3
[...]
@end verbatim

See the command reference for further details regarding the commands
available in @gnubg{}.


@subsection Other formats
@cindex MSN Gaming Zone
@cindex .cbg
@cindex cbg
@cindex FIBS/W
@cindex MacFIBS


There are a number of utilities written that can read and write
positions, matches, and money sessions in other formats than the ones
@gnubg{} has direct support for.

@uref{http://www.wingflyer.com/zoneutilities/,Bunny's Zone Converter}
can be used to convert matches saved on MSN Gaming Zone to Jellyfish
.mat format which can be imported into @gnubg{}. 

The neural net backgammon program 
@uref{http://www.bgblitz.com/,BGBlitz} can read Gamesgrid .cbg, FIBS/W
logfiles, MacFIBS logfiles and other formats which can be written back
in the .mat format for importing into @gnubg{}.

@subsection Tips and tricks

@kindex swap players
@cindex swap players
If you want to exchange the playes, i.e., @gnubg{} has imported you as
the top player rather than the bottom player, select them menu entry
@code{Game->Swap Players}.


@node Exporting
@section Exporting positions, matches, and sessions

@subsection Export game in Jellyfish .gam
@cindex Jellyfish
@cindex .gam
@cindex gam

You can export the current game in the Jellyfish .gam format. This is
useful if you wish import a specific game into Jellyfish. Other
programs may read the file as well, since the format is identical to
the Jellyfish .mat format.

@quotation
@cartouche
@kindex export game gam
@strong{export game gam @var{filename}}:
Export the current game in Jellyfish .gam format to @var{filename}.
@end cartouche
@end quotation

@subsection Export positions, games, matches and sessions in HTML
@cindex HTML
@cindex .html

@gnubg{} can export the current position, game, match or session
in HTML if
you wish to publish it on the web. A
@uref{http://home.online.no/~oeysteij/wc2002/final.html,sample match}
with the World Cup Final 2002 from Monte Carlo is available for
viewing (FIXME: put a match on gnu.org or gnubg.org instead).

@gnubg{} exports in validating 
@uref{http://www.w3.org/TR/xhtml1/,XHTML 1.0} 
with the use of 
@uref{http://www.w3.org/TR/REC-CSS1,CSS}
style sheets. You may add your own style sheet to the exported HTML
files if you wish to override the default layout, e.g., change colors
or fonts. 

The board is made up from hundreds of pictures. Currently, you can
choose between three different sets of pictures.

If you export a match or session to HTML @gnubg{} will write the
individual games to separate files. For example, if you export to file
@file{foo.html} the first game is exported to @file{foo.html}, the
second game to @file{foo_002.html}, the third game to
@file{foo_003.html} and so forth. 

The output from the HTML export can be customised. For example, it's
possible to leave out the 
analysis or parts of the analysis. Also, you may enter a specific URL
to the pictures used to compose the board which is useful for posting
positions on web-based discussion groups such as Kit Woolsey's
@uref{http://www.GammOnLine.com,GammOnLine}
or the 
@uref{http://www.dbgf.dk/,Danish Backgammon Federation's} 
@uref{http://www.dbgf.dk/Debat/,Debat Forum}. 

@xref{Export}, for full details regarding the options available for
HTML export.


@quotation
@cartouche
@kindex export position html
@kindex export game html
@kindex export match html
@kindex export session html
@strong{export position html @var{filename}}:
Export the current position in HTML to @var{filename}.

@strong{export game html @var{filename}}: 
Export the current game in HTML to @var{filename}.

@strong{export match html @var{filename}}: 
Export the current match in HTML to @var{filename}.

@strong{export session html @var{filename}}: 
Export the current session in HTML to @var{filename}.
@end cartouche
@end quotation

@subsection Export games, matches, and sessions in LaTeX
@cindex LaTeX
writeme

@subsection Export match or session in Jellyfish .mat
@cindex Jellyfish
@cindex .mat

You can export an entire match or session into Jellyfish .mat
format. This is very useful if you want to import a match or session
into other programs as most other backgammon programs are
able to read it. 

@quotation
@cartouche
@kindex export match mat
@strong{export match mat @var{filename}}: export the match in
Jellyfish .mat format to @var{filename}.
@end cartouche
@end quotation

@subsection Export games, matches, and sessions in PDF
@cindex PDF
writeme

@subsection Export games, matches, and sessions in PostScript
@cindex PostScript
writeme

@subsection Export position in Jellyfish .pos
@cindex Jellyfish 
@cindex .pos
writeme

@subsection Export position in Snowie .txt position format
@cindex Snowie
@cindex Snowie .txt position format
writeme

@subsection Export positions, games, matches, and sessions in plain text
@cindex text
@cindex plain text



@node Settings
@chapter Settings
@menu
* Player::
* Appearance::
* Options::
* Advanced options::
* Evaluation::
* Analysis::
* Rollouts::
* Export::
@end menu

@node Player
@section Player

@node Appearance
@section Appearance

@node Options
@section Options

@node Advanced options
@section Advanced options

@node Evaluation
@section Evaluation

@include movefilters.texi

@node Analysis
@section Analysis

@node Rollouts
@section Rollouts



@node Export
@section Export

(Joern Thyssen)


@node Analysis and rollouts
@chapter Analysing and rollouts
@menu
* Evaluating a position::
* Evaluating a cube decision::
* Rollout of moves::
* Rollout of cube decisions::
* Analysing a saved game or match or session::
* Output of an analysis::
@end menu

@node Evaluating a position
@section Evaluating a position

@node Evaluating a cube decision
@section Evaluating a cube decision

@node Rollout of moves
@section Rollout of moves


@node Rollout of cube decisions
@section Rollout of cube decisions

@subsection Quasi-Random Dice

Quasi-Random Dice are used to reduce the element of luck in
rollouts. Instead of selecting purely random dice, @gnubg{} will
ensure a uniform distribution of the first roll of the rollout.  If 36
trials is requested, one game will start with 11, two games with 21,
two games with 31, etc. In general, if n * 36 games is requested, n
games will start with 11, 2*n games with 21 etc. This is called
@emph{rotation} of the first roll. Similarly, if n*1296 trials is
requested, the second roll will be rotated, such that n games will
start with 11-11, 2*n games with 11-21, 4*n games with 21-21, etc. The
third roll be also be rotated if the number of trials is proportional
to 46656. 

Suppose a user stops a 1296 trial rollout after 36 games. The 36 games
would have had the following rolls for the first two rolls of each
game: 11-11, 21-11, 12-11, 31-11, 13-11, ..., 66-11 Obviously such a
rollout will give skewed results since the second roll was 11 for all
games! To avoid this problem @gnubg{} will randomise the sequence of
rolls such that it is guaranteed that for any sample of 36 games you
have exactly one game with first roll 11, exactly one game with
second roll 11, etc. This is called @emph{stratification}.

@gnubg{} will actually also rotate and stratify rollouts where the
number of trials are not multiples of 36, 1296, etc. The distribution of
rolls is obviously not uniform any longer in this case, but it will
still provide some reduction of the luck, i.e., no 37 trial rollout
will have 3 games with a initial 66. 

Before the first game of a rollout, @gnubg{} creates a psuedo random
array which it will use for all the games in the rollout. In effect it
has already decided the roll sequence it will use for up to 128 rolls
in every game of the rollout. In other words, for a normal rollout
where games don't go over 64 moves, every single game of every
possible rollout length has already had its dice sequence
determined. During the rollout of game n, sequence n will be used, for
game n+1 sequence n+1, etc. If it's a @emph{rollout as initial
position}, then whenever the current sequence starts with a double,
the sequence is skipped and the dice routine moves on to the next
sequence. Say an @emph{rollout as initial position} is about to start
using sequence 275, but that sequence begins with a double. The dice
routine moves to sequence 276. On the following game, it will use
sequence 277 (it remembers how many it has already skipped). 

So, if you select @emph{rollout as initial position} and 36 games,
then you will get a prefect set of rolls for games 1..30 and the first
6 rolls of the next perfect set (the same rolls you would have gotton
for games 31..36 if you'd asked for 1080 games or 10800 games or 92
games or whatever. 

The dice sequence doesn't know how man trials it will be asked for, it
simply generates sequences such that for a normal rollout
(@emph{rollout as initial position}) every 36 (30) games you get all
possible 1st rolls, every 1296 (1080) games get every possible first 2
rolls, every 46656 (38880) games you get full sets of 3 rolls, etc.






@node Analysing a saved game or match or session
@section Analysing a saved game or match or session

@gnubg{} allows 

@node Output of an analysis
@section Output of an analysis

@subsection Chequer play analysis

@subsection Cube decision analysis

@subsection Game, match, or session statistics

You can get a summary of the analysis from the game, match, or
session analysis. The game analysis is a summary for the current game
whereas the match or session statistics is a summary of all the games
in the match or session. The match analysis is available in the GUI from
@code{Analysis->Match Statistics} or at the botton of exported files.

@subsubsection Chequer play statistics

This section provides a summary of the chequer play statistics. The
following information is available

@itemize @bullet
@item @strong{ Total moves          }:
The total number of moves in the match.
@item @strong{ Unforced moves       }:
The number of unforced moves, i.e., all chequer play decisions
which had more than one legal move. 
@item @strong{ Moves marked xxx}:
The number of moves marked @emph{very good}, @emph{very bad}
etc. The analysis will mark moves @emph{very bad}, @emph{bad}
etc. based on the threshold you've defined in the analysis
settings. @gnubg{} can currently not automatically mark moves, e.g.,
@emph{good}, but you can mark moves @emph{good} yourself.
@item @strong{ Error rate (total)}:
The first number is the total amount of normalised equity that
the player gave up during this game or match. The number in
parenthesis is the un-normalised counterpart; for money play the
all errors are multiplied with the value of the cube, and for match play
the total match winning chance given up by the player is reported. 
@item @strong{ Error rate (per move)}:
The error rate per move is the total error rate divided by the number of
@emph{unforced moves}. Note that is different from Snowie 4 that
defines the error rate per move as the total error rate divided by the
total number of moves for both players, i.e., the sum of @emph{total
moves} for both players. In general, your
error rate per move will be lower in Snowie than in @gnubg{}. 
@item @strong{ Chequer play rating}:
@gnubg{} will assign a rating for your chequer play ranging from
@emph{Awful!} to @emph{Supernatural}. See the description for the
@emph{overall rating} below.
@end itemize


@subsubsection Luck analysis

This section provides information about how Ms. Fortuna distributed
her luck. The following information is available:

@itemize @bullet
@item @strong{ Rolls marked xxx}:
The number of moves marked @emph{very lucky}, @emph{lucky}
etc. Moves marked @emph{very lucky} are huge jokers that improve your
equity with more the +0.6 relative to the average equity. @gnubg{}
normally uses cubeful 0-ply evaluations to calculate the luck, but you
can change that under the analysis settings. See below for a complete
overview of what is considered @emph{very lucky}, @emph{lucky},etc.
@item @strong{ Luck rate (total)}:
The total luck for this game or match reported both normalised
and unnormalised. 
@item @strong{ Luck rate (per move)}:
The luck rate per move reported both normalised and unnormalised.
@item @strong{ Luck rating}:
Based on the luck rate per move @gnubg{} will assign you a
humerous luck rating. See below for the possible ratings.
@end itemize

Thresholds for marking of rolls:

@multitable @columnfractions 0.4 0.4
@item @strong{Deviation of equity from average}
@tab @strong{Roll is marked}
@item >0.6         @tab @emph{very lucky}
@item 0.3 - 0.6    @tab @emph{lucky}
@item -0.3 - 0.3   @tab unmarked
@item -0.6 - -0.3  @tab @emph{unlucky}
@item < -0.6       @tab @emph{very unlucky}
@end multitable

Luck ratings:

@multitable @columnfractions 0.4 0.4
@item @strong{Normalised luck rate per move} 
@tab @strong{Luck rating}
@item > 0.10         @tab Cheater :-)
@item 0.06 - 0.10    @tab Go to Las Vegas immediately
@item 0.02 - 0.06    @tab Good dice, man! 
@item -0.02 - 0.02   @tab none
@item -0.06 - -0.02  @tab Better luck next time
@item -0.06 - -0.10  @tab Go to bed
@item < -0.10        @tab Haaa-haaa
@end multitable


@subsubsection Cube statistics

This section provides a summary of the cube decision statistics: the
number of cube decisions, missed doubles, etc.

@itemize @bullet
@item @strong{ Total cube decisions}:
The total number of cube decisions, i.e., the sum of no-doubles,
doubles, takes, and passes. 
@item @strong{ Close or actual cube decisions}:
Similar to ``Total cube decisions'', except that no-doubles are
only included if they're considered ``close''. @gnubg{} considers a
cube decision close if the relavant equities are within 0.25 from
eachother or if the position is too good. 
@item @strong{ Doubles, Takes, Passes}:
The total number of doubles, takes, and passes in the game or
match.
@item @strong{ Missed doubles around DP, Missed doubles around TG}:
The number of missed doubles around the double point and too good
point respectively. If the
equity is below 0.95 the position is considered to be around the
double point else it considered to be around the too good point. If
you miss doubles around the double point, it usually means that you
double to late, whereas missed doubles around the too good point means
that you're too greedy and play on for gammon when the position is
@emph{not} too good.
@item @strong{ Wrong doubles around DP, Wrong doubles around TG}:
The number of wrong doubles around the double point and too good
point, respectively. If you have missed doubles around the double
point that generally means that you double too early where you really
should hold the cube, whereas missed doubles around the too good point
means that you double positions where you really should play on for a
gammon or backgammon.
@item @strong{ Wrong takes, Wrong passes}:
The total number of wrong takes and passes, respectively.
@item @strong{ Error rate (total)}:
The accumulated cube errors for this game or match reported both
normalised and unnormalised. 
@item @strong{ Error rate (per cube decision)}:
The error rate per cube decision is the total error rate divided
by the number of @emph{close or actual cube decisions}. 
Note that is different from Snowie 4 that
defines the error rate per cube decision as the total error rate divided by the
total number of moves for both players. In general, your
error rate per cube decision will be lower in Snowie than in @gnubg{}. 
@item @strong{ Cube decision rating}:
@gnubg{} will assign a rating for your cube decisions ranging from
@emph{Awful!} to @emph{Supernatural}. See the description for the
@emph{overall rating} below.
@end itemize


@subsubsection Overall rating

The last section is the overall summary.

@itemize @bullet
@item @strong{Error rate (total)}:
The accumulated chequer play and cube decision errors reported by
normalised and unnormalised.
@item @strong{Error rate (per decision)}:
The error rate per decision is the total error rate divided
by the number of non-trivial decisions (i.e., the sum of @emph{unforced
moves} and @emph{close or actual cube decisions}). 
Again, please note that is different from Snowie 4 that
defines the error rate per decision as the total error rate divided by the
total number of moves for both players. In general, your
error rate per move will be lower in Snowie than in @gnubg{}. 
An investigation of approximately 300 matches showed the on average
the @gnubg{} error rate with be 1.4 times higher than your Snowie 4
error rate. 
@item @strong{Equivalent Snowie error rate}:
For easy comparison @gnubg{} will also print the total error rate
calculated by the same formulae as Snowie 4. 
@item @strong{Overall rating}:
Based on your normalised error rate per move @gnubg{} will assign
you a rating ranging from @emph{Awful!} to @emph{Supernatural}. See
the table below for the thresholds.
@item @strong{Actual result}:
The actual result of the game or match. For money game this is simply the
number of points won or lost during the game or match. For match play
the number is calculated as 50% added to the result of the game or
match in MWC. For example, losing a match or winning a match
corresponds to an actual result of 0% and 100%, respectively. Winning
1 point in the first game of 7 point match is worth 6% using Kit
Woolsey's match equity table, hence the actual result is 56%. 
@item @strong{Luck adjusted result}:
The luck adjusted result is calculated as the @emph{actual result}
plus the total unnormalised luck rate. This is also called ``variance
reduction of skill'' as described in Douglas Zare's excellent article
@url{http://math.columbia.edu/~zare/vrskill.html,Hedging Toward
Skill}. This should give an unbiased measure of the strengths of the
players. 
@item @strong{MWC against current opponent}:
For match play @gnubg{} will calculate your MWC
against the current opponent. The number is calculated as 50% - your
total unnormalised error rate + your opponent's total unnormalised
error rate. If your opponent is really lucky but plays rather bad, this
number can become larger than 100%, since he due to the extra luck has
the possibily to give up even more MWC. However, @gnubg{} will
report this number as 100%, and 0% for the opposite situation. Note
that this number is biased towards the analysing bot, e.g., a 0-ply
analysis a game between @gnubg{} 2-ply and 0-ply will suggest that
0-ply is a favourite, which it is clearly not. For an unbiased measure
use the @emph{luck adjusted result} above.
@item @strong{Guestimated abs. rating}:
writeme
@end itemize

Threshold for ratings:

@multitable @columnfractions 0.4 0.4
@item @strong{Normalised total error rate per move} 
@tab @strong{Rating}
@item 0.000 - 0.002   @tab Supernatural
@item 0.002 - 0.005   @tab World Class
@item 0.005 - 0.008   @tab Expert
@item 0.008 - 0.012   @tab Advanced
@item 0.012 - 0.018   @tab Intermediate
@item 0.018 - 0.026   @tab Casual Player
@item 0.026 - 0.035   @tab Beginner
@item > 0.035         @tab Awful!
@end multitable



@node Position and match IDs
@chapter Position and match IDs
@menu
* A technical description of the position ID::
* A technical description of the match ID::
@end menu

@node A technical description of the position ID
@section A technical description of the position ID
@cindex position ID

@subsection Introduction

This section describes a method for compactly recording a backgammon
position. It demonstrates how to encode a position into 10 binary
bytes, which is useful for minimising the space used when recording
large numbers of positions in memory or on disk. There is also an
ASCII representation in 14 characters, which is convenient for output
to the screen, for copying and pasting to transfer positions between
programs which support the format, and for communicating positions via
Usenet news or e-mail. The 10 byte binary format is called the @emph{key},
and the 14 character ASCII format is the @emph{ID}. 

@subsection Key format

The key is essentially a bit string (imagine you start with an empty
sequence of bits, and continue adding either "0" or "1" to the
end). The way to build up a sequence that corresponds to a given
position is: 

@enumerate
@item  For every point around the board (starting at the ace point of
the player on roll, continuing around to the 24 point and ending at
the bar): 
@enumerate
@item append as many 1s as the player on roll has on that point (if any).
@item append a 0. 
@end enumerate

@item For every point around the board (starting at the ace point of
the opponent, continuing around to the opponent's 24 point and ending
at the bar): 
@enumerate
@item append as many 1s as the opponent has on that point (if any).
@item append a 0. 
@item Pad out the string to 80 bits with 0s. 
@end enumerate

@end enumerate

The worst-case representation will require 80 bits: you can see that
there are always 50 0 bits even if there are no chequers at all. Each
player has a maximum of 15 chequers in play (not yet borne off) which
require a 1 bit wherever they are positioned. That's 30 bits to take
of all chequers, plus the 50 bits of overhead for a total of 80 bits
(the last bit is always 0 and isn't strictly necessary, but it makes
the code slightly easier). This bit string should be stored in
little-endian order when packed into bytes (ie. the first bits in the
string are stored in the least significant bits of the first byte). 

As an example, here's what the starting position looks like in the key
format:

@multitable @columnfractions 0.33 0.33
@item 0 0 0 0 0          @tab player on roll has no chequers on ace to 5 points
@item 11111 0            @tab 5 chequers on the 6 point
@item 0                  @tab empty bar
@item 111 0              @tab 3 on the 8
@item 0 0 0 0            @tab no others in our outfield
@item 11111 0            @tab 5 on the midpoint
@item 0 0 0 0 0          @tab none in the opponent's outfield
@item 0 0 0 0 0          @tab or in opponent's board, until...
@item 11 0               @tab two on the 24 point
@item 0                  @tab none on the bar
@item 0 0 0 0 0          @tab opponent has no chequers on ace to 5 points
@item 11111 0            @tab 5 chequers on the 6 point
@item 0                  @tab empty bar
@item 111 0              @tab 3 on the 8
@item 0 0 0 0            @tab no others in opponent's outfield
@item 11111 0            @tab 5 on the midpoint
@item 0 0 0 0 0          @tab none in our outfield
@item 0 0 0 0 0          @tab or in our board, until...
@item 11 0               @tab two on the 24 point
@item 0                  @tab none on the bar
@end multitable

so altogether it's:

00000111110011100000111110000000000011000000011111001110000011111000000000001100

In little endian bytes it looks like:

11100000 01110011 11110000 00000001 00110000 11100000 01110011 11110000 00000001 00110000
   0xE0     0x73     0xF0     0x01     0x30     0xE0     0x73     0xF0     0x01     0x30

so the 10 byte key (in hex) is E0 73 F0 01 30 E0 73 F0 01 30.
ID format

The ID format is simply the 
@uref{http://www.ietf.org/rfc/rfc2045.txt,Base64}
encoding of the key. (Technically,
a Base64 encoding of 80 binary bits should consist of 14 characters
followed by two = padding characters, but this padding is omitted in
the ID format.) 

To continue the above example, splitting the 10 8-bit bytes into 14
6-bit groups gives: 

111000 000111 001111 110000 000000 010011 000011 100000 011100 111111 000000 000001 001100 000000

In Base64 encoding, these groups are respectively represented as:

4      H      P     w      A      T      D      g      c      /      A      B      M      A

So, the position ID of the chequers at the start of the game is simply:

4HPwATDgc/ABMA

You can set the board in @gnubg{} either by writing the position ID
into the position text input field in the GUI or by executing the
command @code{set board 4HPwATDgc/ABMA}.

@subsection Notes

@itemize
@item This encoding is obviously not as compact as it could be: in
particular, there are lots of redundant representations of illegal
positions where both players have chequers on the same
point. Theoretically, it would be possible to get it down to 64 bits
by using 
@uref{http://www.bkgm.com/rgb/rgb.cgi?view+371,Walter Trice's
"D() expressions"}, but I think you'd have to 
be a mathematical masochist to try it! 
@item 
@uref{http://savannah.gnu.org/cgi-bin/viewcvs/gnubg/gnubg/positionid.c?rev=HEAD&sortby=date&content-type=text/vnd.viewcvs-markup,Example
code} 
to convert between a raw board encoding (the number of chequers on
each point) and these keys/IDs is available licensed under GPL. 
@item Thanks to Tom Keith and David desJardins for their suggestions
on simplifying the encoding without increasing the worst case length.  
@end itemize

@node A technical description of the match ID
@section A technical description of the match ID
@cindex match ID

@subsection Introduction

This section describes how the match ID is calculated. The match ID  can
be used for easy exchange of positions for @gnubg{} users in
conjuction with the position ID. The match key is a 9 byte
representation of the match score, match length, value of cube, owner of
cube, Crawford game flag, player on roll, player to make a decision,
doubled flag, resigned flag, and the dice rolled. The match ID is the 12
character Base64 encoding of the match key.

@subsection Match key

The match key is a bit string of length 66:

@enumerate
@item
Bit 1-4 contains the 2-logarithm of the cube value. For example, a
8-cube is encoded as 0011 binary (or 3), since 2 to the power of 3 is
8. The maximum value of the cube in with this encoding is 2 to the power
of 15, i.e., a 32768-cube.

@item
Bit 5-6 contains the cube owner. 00 if player 0 owns the cube, 01 if
player 1 owns the cube, or 11 for a centered cube.

@item
Bit 7 is the player on roll or the player who did roll (0 and 1 for
player 0 and 1, respectively).  

@item
Bit 8 is the Crawford flag: 1 if this game is the Crawford game, 0
otherwise.

@item
Bit 9-11 is the game state: 000 for no game started, 001 for playing a game,
010 if the game is over, 011 if the game was resigned, or 100 if the
game was ended by dropping a cube.

@item
Bit 12 indicates whose turn it is. For example, suppose player 0 is on
roll then bit 7 above will be 0. Player 0 now decides to double, this
will make bit 12 equal to 1, since it is now player 1's turn to decide
whether she takes or passes the cube.

@item
Bit 13 indicates whether an doubled is being offered. 0 if no double is
being offered and 1 if a double is being offered.

@item
Bit 14-15 indicates whether an resignation was offered. 00 for no
resignation, 01 for resign of a sigle game, 10 for resign of a gammon,
or 11 for resign of a backgammon. The player offering the resignation is
the inverse of bit 12, e.g., if player 0 resigns a gammon then bit 12
will be 1 (as it is now player 1 now has to decide whether to accept or
reject the resignation) and bit 13-14 will be 10 for resign of a gammon.

@item
Bit 16-18 and bit 19-21 is the first and second die, respectively. 0 if
the dice has not yet be rolled, otherwise the binary encoding of the
dice, e.g., if 5-2 was rolled bit 16-21 will be 101-010.

@item
Bit 22 to 36 is the match length. The maximum value for the match length
is 32767. A matchscore of zero indicates that the game is a money game.

@item
Bit 37-51 and bit 52-66 is the score for player 0 and player 1
respectively. The maximum value of the match score is 32767.

@end enumerate

For example, assume the score is 2-4 in a 9 point match with player 0
holding a 2-cube, and player 1 has just rolled 52. The match key for
this will be (note that the bit order is reversed below for readability)

1000 00 1 0  100 1 0 00 101 010 100100000000000 010000000000000 001000000000000            


In little endian the bytes looks like:

01000001 10001001 00101010 00000001 00100000 00000000 00100000 00000000 00

0x41     0x89     0x2A     0x01     0x20     0x00     0x20     0x00     0x00

@subsection Match ID

Analogous to the position ID from the previous section the match ID
format is simply the Base64 encoding of the key. 

To continue the example above, the 9 8-bit bytes are grouped into 12
6-bits groups:


010000 011000 100100 101010 000000 010010 000000 000000 001000 000000
000000 000000

In Base64 encoding, the groups are represented as:

Q Y k q A S A A I A A A

So, the match id is simply:

QYkqASAAIAAA

If someone post a match ID you can set up the position in @gnubg{} by
writing or pasting it into the Match ID text input field on the main
window, or by executing the command @code{set matchid QYkqASAAIAAA}.


@include cubeful.texi


@node Training
@chapter Training

@include bearoff.texi

@include faq.texi


@include fdl.texi


@node Command Index
@unnumbered Command Index
@printindex ky

@node Concept Index
@unnumbered Index
@printindex cp


@bye
